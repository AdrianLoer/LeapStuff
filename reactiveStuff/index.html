<!DOCTYPE HTML>
<html>
<head>
	<style>
		body {
			margin: 0px;
			padding: 0px;
		}

		canvas {
			position: absolute;
			top: 0;
			left: 0;
			margin: -30px;
		}

		.map {
			width: 100%;
			height: 100%;
			position: absolute;
		}

	</style>
	<script src="../libs/jquery-2.1.4.min.js"></script>
	<script src="../libs/brain-0.6.3.js"></script>
	<script src="./v3.11.2-dist/ol-debug.js"></script>
	<script src="../libs/Bacon.js"></script>
	<script src="../libs/dat.gui.js"></script>
	<script src="../libs/three.js"></script>
	<script src="../libs/leap-0.6.4.js"></script>
	<script src="../libs/mathUtility.js"></script>
	<script src="../libs/leap-plugins-0.1.11.js"></script>
</head>
<body>
	<input id="output" style="position: absolute; top: 10px; left: 10px"></body>
</body>
<script>

	window.output = [];



	var recordFrameEventStream = $(window).asEventStream("keydown");

	var net = new brain.NeuralNetwork();

	$.getJSON( "./distance_training_net.json", function(data) {
		net = net.fromJSON(data);
	});


	var controller = new Leap.Controller({enableGestures: false}).setBackground(false);

	function frameStream(controller) {
		return Bacon.fromBinder(function(sink) {
			controller.loop(function(frame) {
				sink(frame);
			})
			.use('boneHand', {
				targetEl: document.body,
				arm: true
			});
			return function() {
				console.log("frameStream off");
			}
		})
	}

	var frameStream = frameStream(controller);

	frameStream.onValue(function(value) {
		window.frameObject = value;
	});

	var handOneStream = frameStream.map(function(value) {
		return value.hands[0];
	})

	var fingers = [];

	for (var i = 0; i < 5; i++) {  
		(function(i) {
			// might have to change to work with 2 hands
			fingers.push(handOneStream.filter(function(value) {return value !== undefined}).map(function(value) {return value.fingers[i]}));
		})(i);
	}

	var bones = [[],[],[],[],[]];

      // starting from tip

      for (var i = 0; i < 5; i++) {
      	bones[i][0] = fingers[i].filter(function(value) {return value !== undefined}).map(function(value) {return value.tipPosition});
      	bones[i][1] = fingers[i].filter(function(value) {return value !== undefined}).map(function(value) {return value.dipPosition});
      	bones[i][2] = fingers[i].filter(function(value) {return value !== undefined}).map(function(value) {return value.pipPosition});
      	bones[i][3] = fingers[i].filter(function(value) {return value !== undefined}).map(function(value) {return value.mcpPosition});
      	bones[i][4] = fingers[i].filter(function(value) {return value !== undefined}).map(function(value) {return value.carpPosition});
      }

      // bones[3][3].log();

      var palmPosition = handOneStream.filter(function(value){return value !== undefined}).map(function(value) {return value.palmPosition});


      var blueMesh = new THREE.Mesh(new THREE.SphereGeometry(5, 10, 10), new THREE.MeshLambertMaterial({color: 0x091DFF}));
      // var redMesh = new THREE.Mesh(new THREE.SphereGeometry(5, 10, 10), new THREE.MeshLambertMaterial({color: 0xFF0007}));
      // var yellowMesh = new THREE.Mesh(new THREE.SphereGeometry(5, 10, 10), new THREE.MeshLambertMaterial({color: 0xFFF200}));
      controller.plugins.boneHand.scene.add(blueMesh);

      palmPosition.onValue(function(value) {
      	blueMesh.position.fromArray(value);
      })

      // starting from thumb
      var tipDistances = [[],[],[],[]];

      tipDistances[0] = Bacon.zipAsArray(bones[0][0], bones[1][0]).map(function(value) {
      	return Leap.vec3.distance(value[0], value[1]);
      });

      tipDistances[1] = Bacon.zipAsArray(bones[1][0], bones[2][0]).map(function(value) {
      	return Leap.vec3.distance(value[0], value[1]);
      });

      tipDistances[2] = Bacon.zipAsArray(bones[2][0], bones[3][0]).map(function(value) {
      	return Leap.vec3.distance(value[0], value[1]);
      });

      tipDistances[3] = Bacon.zipAsArray(bones[3][0], bones[4][0]).map(function(value) {
      	return Leap.vec3.distance(value[0], value[1]);
      });


      var armOneAngleStream = handOneStream.filter(function(value){return value !== undefined}).map(function(value) {
    		return mUtil.vecAngleLinePlane(value.direction, Leap.vec3.fromValues(0, 1, 0));
      });

      var tipAnglesToArm = [[],[],[],[],[]];
      // tipAnglesToArm[0] = 

      // Bacon.zipAsArray(handOneStream.filter(function(value){return value !== undefined}), bones[0][0], bones[0][4]).map(function(value) {
      Bacon.zipAsArray(fingers[1].filter(function(value) {return value !== undefined}), bones[1][0], bones[1][4]).map(function(value) {
      	// tipPosition and carpPosition of a finger
      	Leap.vec3.subtract(temporaryVector, value[1], value[2]);
      	// console.log(temporaryVector);
      	// return Leap.vec3.subtract(temporaryVector, value[0], value[1])
      	// console.log(mUtil.vecAngleLinePlane(perpendicularVectorToPlane, temporaryVector));
      	console.log(value[0]);

    		// return mUtil.vecAngleLinePlane(value[0].direction, Leap.vec3.normalize(temporaryVector);
    		// return mUtil.vecAngleLinePlane(temporaryVector, Leap.vec3.fromValues(0, 1, 0));
    		return mUtil.vecAngleLinePlane(value[0].bones[3].direction(), Leap.vec3.fromValues(0, 1, 0));
      }).log()


      var temporaryVector = Leap.vec3.create();
      var perpendicularVectorToPlane = Leap.vec3.create();

      // function calculateFingerAngleData(frame) {
    		// 	Leap.vec3.subtract(temporaryVector, frame.hands[0].fingers[i].tipPosition, frame.hands[0].fingers[i].carpPosition);
      // 			frameDataStore.fingers[i].angle = mUtil.vecAngleLinePlane(perpendicularVectorToPlane, temporaryVector);
      //   }
      // }






      // frameStream.log();
      // t
      var trainCaseTrue = Bacon.zipAsArray(tipDistances).sampledBy(recordFrameEventStream.filter(function(value) {return value.keyCode === 84}))
      .map(function(value) {
      	return value.map(function(val) {
      		return val / 100;
      	});
      })
      .map(function(value) {
      	var trainCase =  {
      		input: value,
      		output: [1]
      	}
      	return trainCase;
      });

      // f
      var trainCaseFalse = Bacon.zipAsArray(tipDistances).sampledBy(recordFrameEventStream.filter(function(value) {return value.keyCode === 70}))
      .map(function(value) {
      	return value.map(function(val) {
      		return val / 100;
      	});
      })
      .map(function(value) {
      	var trainCase =  {
      		input: value,
      		output: [0]
      	}
      	return trainCase;
      });



      trainCaseTrue.merge(trainCaseFalse).onValue(function(value) {
      	window.output.push(value);
      });


      var gestureCheckStream = Bacon.combineAsArray(tipDistances)
      .map(function(value) {
      	return value.map(function(val) {
      		return val / 100;
      	})
      })
      .map(function(value) {
      	return net.run(value);
      // }).log();
    	});


    </script>
    </html>






















